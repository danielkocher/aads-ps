\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[linesnumbered]{algorithm2e}
\usepackage[margin=.6in]{geometry}
\begin{document}
%
\title{Assignment 1 \\ Advanced Algorithms \& Data Structures PS}%
\author{Christian Müller 1123410 \\ Daniel Kocher, 0926293}%
\maketitle%
\clearpage%
%
\noindent%
{\bfseries Aufgabe 2} \newline%
Geben Sie einen Pseudocode f{\"u}r das Divide\&Conquer Verfahren \texttt{ReportCuts} aus der Vorlesung an.%

\begin{algorithm}[ht]
  \SetKwProg{Fn}{Function}{}{}%
  \SetKwInOut{Input}{Input}%
  \SetKwInOut{Output}{Output}%
  \SetKwInOut{Variables}{Variables}%
%
  \Input{
    Menge $S$ bestehend aus vertikalen Segmenten und Endpunkten von horizontalen Segmenten. \\
    $S$ sei nach horizontalen Koordinaten sortiert. Falls $S$ unsortiert vorliegt, muss $S$ vor jedem \\
    \texttt{Divide Schritt} nach horizontalen Koordinaten sortiert werden.
  }%
  \Output{Alle Schnittpunkte von vertikalen Segmenten mit horizontalen Segmenten, von denen mindestens ein Endpunkt in $S$ ist}%
  \Variables{
    $L(S)$ enth{\"a}lt die y-Koordinaten aller linken Eckpunkte in $S$, deren rechter Partner nicht in $S$. \\
    $R(S)$ enth{\"a}lt die y-Koordinaten aller rechten Eckpunkte in $S$, deren linker Partner nicht in $S$. \\
    $V(S)$ enth{\"a}lt die y-Intervalle der vertikalen Segmente in $S$. \\
    $L(S)$ und $R(S)$ sind nach steigenden y-Koordinaten sortierte, verkettete Listen. \\
    $V(S)$ sind nach steigenden unteren Endpunkten sortierte, verkettete Listen.
  }%
  \Fn{ReportCuts($S$)}{%
    \If{$|S| \le 1$}{
      \tcp{Initialisierung von $L(S)$, $R(S)$ und $V(S)$}
      Sei $s = (x, y)\in S$\;
      \BlankLine%
      \lIf{$s$ ist linker Endpunkt}{$L(S) \leftarrow \{y\}$, $R(S) \leftarrow \emptyset$, $V(S) \leftarrow \emptyset$}%
      \BlankLine%
      \lElseIf{$s$ ist rechter Endpunkt}{$L(S) \leftarrow \emptyset$, $R(S) \leftarrow \{y\}$, $V(S) \leftarrow \emptyset$}% 
      \BlankLine%
      \lElseIf{$S$ enth{\"a}lt nur das vertikale Segmente $v$}{$L(S) \leftarrow \emptyset$, $R(S) \leftarrow \emptyset$, $V(S) \leftarrow \{[y_1, y_2]\}$}% 
      \BlankLine%
      \Return \tcp*{Rekursionsende}%
    }%
    %\BlankLine%
    %\If{$S$ ist nicht nach horizontalen Koordinaten sortiert}{Sortiere $S$ nach horizontalen Koordinaten\;}%
    %\BlankLine\BlankLine%
    \tcp{Divide Schritt}%
    Teile $S$ per vertikaler Trennlinie in zwei (nahezu) gleich gro{\ss}e Teile $S_1$ und $S_2$ auf\;%
    \BlankLine\BlankLine%
    \tcp{Conquer Schritt}%
    ReportCuts($S_1$)\;%
    ReportCuts($S_2$)\;%
    \BlankLine\BlankLine%
    \tcp{$L(S_i)$, $R(S_i)$, $V(S_i)$ f{\"u}r $i = 1, 2$ bekannt $\Rightarrow$ Merge Schritt}
    \tcp{Berichte Segmentschnittpunkte (Paare $(h, v)$); $y(x)$ sei die y-Koordinate von $x$}
    Bestimme alle Paare $(h, v)$ f{\"u}r die entweder ($hv_1$) oder ($hv_2$) gilt\;
    \Begin($hv_1$){%
      Sei $y(h)\in R(S_2) \setminus L(S_1)$ und $[y_{unten}(v), y_{oben}(v)]\in V(S_1)$\;%
      \lIf{$y_{unten}(v) \le y(h) \le y_{oben}(v)$}{print $(h, v)$}%
    }
    \BlankLine\BlankLine%
    \Begin($hv_2$){%
      Sei $y(h)\in L(S_1) \setminus R(S_2)$ und $[y_{unten}(v), y_{oben}(v)]\in V(S_2)$\;%
      \lIf{$y_{unten}(v) \le y(h) \le y_{oben}(v)$}{print $(h, v)$}%
    }
    \BlankLine\BlankLine%
    \tcp{Aktualisiere $L(S)$, $R(S)$ und $V(S)$ f{\"u}r $S = S_1 \cup S_2$}
    \ForEach{Paar zusammengeh{\"o}riger horizontaler Endpunkte}{%
      $L(S) = \left( L(S_1) \setminus R(S_2) \right) \cup L(S_2)$\;
      $R(S) = \left( R(S_2) \setminus L(S_1) \right) \cup R(S_1)$\;
    }
    $V(S) = V(S_1) \cup V(S_2)$\;
  }%
\end{algorithm}

%\begin{algorithm}[H]
%
%\SetKwProg{Fn}{Function}{}{}
%\SetKwInOut{Input}{input}
%\SetKwInOut{Output}{output}
%
% \Input{Menge von horizontalen Segmenten $H$  und eine Menge von vertikalen Segmenten $V$. Sei $H^{\ast}$ die Menge der Endpunkte der horizontalen Segmente und $S=H^{\ast} \cup V$.}
% \Output{Paare $(h,v)$ mit $h \in H$ und $v \in V$.}
%Sortiere Element von S gemäß ihrer horizontalen Position.\;
%ReportCuts($S$,$L_{S}$,$R_{S}$,$V_{S}$)\;
%\Fn{ReportCuts ($S$,$L_{S}$,$R_{S}$,$V_{S}$)}{
%
% \eIf{$|S|==1$ \tcp*{Sei p dieses Element}}{
%   \Begin{
%        \Switch{p}{
%            \Case{p ist linker Endpunkt}{
%                $L_{S}\leftarrow p_{y}$, $R_{S}\leftarrow \emptyset$, $V_{S}\leftarrow \emptyset$ \Return;
%            }
%             \Case{p ist rechter Endpunkt}{
%                $L_{S}\leftarrow \emptyset$, $R_{S}\leftarrow p_{y}$, $V_{S}\leftarrow \emptyset$ \Return;
%            }
%              \Case{p vertikales Segment}{
%                $L_{S}\leftarrow \emptyset$, $R_{S}\leftarrow \emptyset$, $V_{S}\leftarrow (p_{y1},p_{y2})$ \Return;
%            }
%        }
%    }
%   
%   }{
%   Wähle eine geeignete vertikale Trennlinie (dh. beliebige x-Koordinate), welche die Menge S in zwei gleich große Teilmengen $S1$ und $S2$ teilt\;
%    ReportCuts($S1$,$L_{S1}$,$R_{S1}$,$V_{S1}$)\;
%    ReportCuts($S2$,$L_{S2}$,$R_{S2}$,$V_{S2}$)\;
%    $tmp \leftarrow L_{S1} \cap R_{S2}$\;
%    \tcc{$tmp$ enhält so alle horizontalen Segmente, die in $S1$ beginnen und in $S2$ enden.}
%    print($(L_{S1} \setminus tmp) \odot V_{S2}$)\;
%    \tcc{$(L_{S1} \setminus tmp)$ enhält  alle horizontalen Segmente, die in $S1$ beginnen und nicht in $S2$ enden. $h \odot V_{2}$ liefert alle $v \in V_{S2}$, die $h_{y}$ enthalten. Genaue Vorgehensweise ist den Folien der Vorlesung zu entnehmen.}
%    print($(R_{S2} \setminus tmp) \odot V_{S1}$)\;
%     \tcc{analog zu letztem print. Horizontale Segmente die in $S2$ enden und ihren Anfangspunkt nicht in $S1$ haben geschnitten mit den vertikalen Segmenten aus $S1$.}
%    $L_{S}\leftarrow (L_{S1} \setminus tmp) \cup L_{S2}$\;
%   	$R_{S}\leftarrow (R_{S2} \setminus tmp) \cup R_{S1}$\;
%   	$V_{S}\leftarrow V_{S1} \cup V_{S2}$\;
%   	\Return\;
%  }
% 
%}
%\caption{PLG}
% \caption{CutReporter}
%\end{algorithm}

\end{document}
